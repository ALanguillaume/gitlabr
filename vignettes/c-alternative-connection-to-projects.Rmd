---
title: "Alternative connections to projects"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{c-Alternative connections to projects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

```{r setup}
library(gitlabr)
```

# Creating connections

The idea of connections in {gitlabr} is to generate functions with the same signature and capability as that of the central API call function `gitlab()`, but with certain parameters set to fixed values (["curried"](https://en.wikipedia.org/wiki/Currying)).
This way these more specialized functions represent and provide the connection -- for example -- to a specific GitLab instance as a specific user.
Such specialized functions can be created with the function `gitlab_connection()` and then used exactly as you would use `gitlab()`:

```{r eval = FALSE}
my_gitlab <- gl_connection("https://gitlab.com",
                           private_token = Sys.getenv("GITLAB_COM_TOKEN"))
my_gitlab("projects")
```

```{r echo = FALSE, eval = FALSE, message=FALSE}
library(dplyr)
my_gitlab("projects") %>%
  filter(public == "TRUE") %>%
  select(name, everything())
```

`gitlab_connection()` can take arbitrary parameters, returning a function that issues API requests with these parameter values.

`gl_project_connection()` can be used as a convenience wrapper to directly connect to a specific project in a GitLab instance. 

## function-in-function style

When calling the `gitlab()`function, the query is passed through the `req` argument as a vector of characters (e.g. "projects").
Another option is to pass a *function* to the `req` argument that will then be called along with the additional parameters, using the connection for all API calls :

```{r eval = FALSE}
my_gitlab(gl_create_issue, "Implement new feature", project = my_project)
```

`gl_create_issue()` is an example function here, the principle style works for all convenience functions of {gitlabr} starting with `gl_*()`.

Some of the convenience functions perform additional transformation or renaming of parameters.
Hence, the parameters given to the exemplary `my_gitlab(...)` call after the function should be valid according to the specified function's documentation, and may differ from names used in the GitLab API itself, although this occurs only very rarely.
